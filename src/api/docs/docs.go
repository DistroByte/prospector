// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/health": {
            "get": {
                "security": [
                    {
                        "None": []
                    }
                ],
                "description": "Check if the API is up and running",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Health check",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/controllers.Message"
                        }
                    }
                }
            }
        },
        "/jobs": {
            "get": {
                "security": [
                    {
                        "None": []
                    }
                ],
                "description": "Get all jobs from nomad",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "job"
                ],
                "summary": "Get all jobs",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Get long job details",
                        "name": "long",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/structs.JobListStub"
                            }
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "None": []
                    }
                ],
                "description": "Create and submit a job to nomad to deploy",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "job"
                ],
                "summary": "Create a job",
                "parameters": [
                    {
                        "description": "Job",
                        "name": "job",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.Job"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/controllers.Message"
                        }
                    }
                }
            }
        },
        "/jobs/{id}": {
            "get": {
                "security": [
                    {
                        "None": []
                    }
                ],
                "description": "Get a job from nomad",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "job"
                ],
                "summary": "Get a job",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Job ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/structs.Job"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "None": []
                    }
                ],
                "description": "Delete a job from nomad",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "job"
                ],
                "summary": "Delete a job",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Job ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "boolean",
                        "description": "Purge job",
                        "name": "purge",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/controllers.Message"
                        }
                    }
                }
            }
        },
        "/v1/auth": {
            "get": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "description": "Check if the API is up and running",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Authenticated Health check",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/controllers.Message"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "controllers.Job": {
            "type": "object",
            "required": [
                "image",
                "name"
            ],
            "properties": {
                "cpu": {
                    "type": "integer",
                    "maximum": 2000,
                    "minimum": 0
                },
                "image": {
                    "type": "string"
                },
                "memory": {
                    "type": "integer",
                    "maximum": 2000,
                    "minimum": 0
                },
                "name": {
                    "type": "string"
                },
                "port": {
                    "type": "integer",
                    "maximum": 65535,
                    "minimum": 0
                }
            }
        },
        "controllers.Message": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "structs.Action": {
            "type": "object",
            "properties": {
                "args": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "command": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "structs.Affinity": {
            "type": "object",
            "properties": {
                "ltarget": {
                    "description": "Left-hand target",
                    "type": "string"
                },
                "operand": {
                    "description": "Affinity operand (\u003c=, \u003c, =, !=, \u003e, \u003e=), set_contains_all, set_contains_any",
                    "type": "string"
                },
                "rtarget": {
                    "description": "Right-hand target",
                    "type": "string"
                },
                "weight": {
                    "description": "Weight applied to nodes that match the affinity. Can be negative",
                    "type": "integer"
                }
            }
        },
        "structs.CSIMountOptions": {
            "type": "object",
            "properties": {
                "fstype": {
                    "description": "FSType is an optional field that allows an operator to specify the type\nof the filesystem.",
                    "type": "string"
                },
                "mountFlags": {
                    "description": "MountFlags contains additional options that may be used when mounting the\nvolume by the plugin. This may contain sensitive data and should not be\nleaked.",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "structs.CSIPluginType": {
            "type": "string",
            "enum": [
                "node",
                "controller",
                "monolith"
            ],
            "x-enum-varnames": [
                "CSIPluginTypeNode",
                "CSIPluginTypeController",
                "CSIPluginTypeMonolith"
            ]
        },
        "structs.CSIVolumeAccessMode": {
            "type": "string",
            "enum": [
                "",
                "single-node-reader-only",
                "single-node-writer",
                "multi-node-reader-only",
                "multi-node-single-writer",
                "multi-node-multi-writer"
            ],
            "x-enum-varnames": [
                "CSIVolumeAccessModeUnknown",
                "CSIVolumeAccessModeSingleNodeReader",
                "CSIVolumeAccessModeSingleNodeWriter",
                "CSIVolumeAccessModeMultiNodeReader",
                "CSIVolumeAccessModeMultiNodeSingleWriter",
                "CSIVolumeAccessModeMultiNodeMultiWriter"
            ]
        },
        "structs.CSIVolumeAttachmentMode": {
            "type": "string",
            "enum": [
                "",
                "block-device",
                "file-system"
            ],
            "x-enum-varnames": [
                "CSIVolumeAttachmentModeUnknown",
                "CSIVolumeAttachmentModeBlockDevice",
                "CSIVolumeAttachmentModeFilesystem"
            ]
        },
        "structs.ChangeScript": {
            "type": "object",
            "properties": {
                "args": {
                    "description": "Args is a slice of arguments passed to the script",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "command": {
                    "description": "Command is the full path to the script",
                    "type": "string"
                },
                "failOnError": {
                    "description": "FailOnError indicates whether a task should fail in case script execution\nfails or log script failure and don't interrupt the task",
                    "type": "boolean"
                },
                "timeout": {
                    "description": "Timeout is the amount of seconds we wait for the script to finish",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                }
            }
        },
        "structs.CheckRestart": {
            "type": "object",
            "properties": {
                "grace": {
                    "description": "Grace time to give tasks after starting to get healthy",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "ignoreWarnings": {
                    "description": "If true treat checks in ` + "`" + `warning` + "`" + ` as passing",
                    "type": "boolean"
                },
                "limit": {
                    "description": "Restart task after this many unhealthy intervals",
                    "type": "integer"
                }
            }
        },
        "structs.Constraint": {
            "type": "object",
            "properties": {
                "ltarget": {
                    "description": "Left-hand target",
                    "type": "string"
                },
                "operand": {
                    "description": "Constraint operand (\u003c=, \u003c, =, !=, \u003e, \u003e=), contains, near",
                    "type": "string"
                },
                "rtarget": {
                    "description": "Right-hand target",
                    "type": "string"
                }
            }
        },
        "structs.Consul": {
            "type": "object",
            "properties": {
                "cluster": {
                    "description": "Cluster (by name) to send API requests to",
                    "type": "string"
                },
                "namespace": {
                    "description": "Namespace in which to operate in Consul.",
                    "type": "string"
                },
                "partition": {
                    "description": "Partition is the Consul admin partition where the workload should\nrun. Note that this should never be defaulted to \"default\" because\nnon-ENT Consul clusters don't have admin partitions",
                    "type": "string"
                }
            }
        },
        "structs.ConsulConnect": {
            "type": "object",
            "properties": {
                "gateway": {
                    "description": "Gateway is a Consul Connect Gateway Proxy.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ConsulGateway"
                        }
                    ]
                },
                "native": {
                    "description": "Native indicates whether the service is Consul Connect Native enabled.",
                    "type": "boolean"
                },
                "sidecarService": {
                    "description": "SidecarService is non-nil if a service requires a sidecar.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ConsulSidecarService"
                        }
                    ]
                },
                "sidecarTask": {
                    "description": "SidecarTask is non-nil if sidecar overrides are set",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.SidecarTask"
                        }
                    ]
                }
            }
        },
        "structs.ConsulExposeConfig": {
            "type": "object",
            "properties": {
                "paths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.ConsulExposePath"
                    }
                }
            }
        },
        "structs.ConsulExposePath": {
            "type": "object",
            "properties": {
                "listenerPort": {
                    "type": "string"
                },
                "localPathPort": {
                    "type": "integer"
                },
                "path": {
                    "type": "string"
                },
                "protocol": {
                    "type": "string"
                }
            }
        },
        "structs.ConsulGateway": {
            "type": "object",
            "properties": {
                "ingress": {
                    "description": "Ingress represents the Consul Configuration Entry for an Ingress Gateway.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ConsulIngressConfigEntry"
                        }
                    ]
                },
                "mesh": {
                    "description": "Mesh indicates the Consul service should be a Mesh Gateway.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ConsulMeshConfigEntry"
                        }
                    ]
                },
                "proxy": {
                    "description": "Proxy is used to configure the Envoy instance acting as the gateway.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ConsulGatewayProxy"
                        }
                    ]
                },
                "terminating": {
                    "description": "Terminating represents the Consul Configuration Entry for a Terminating Gateway.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ConsulTerminatingConfigEntry"
                        }
                    ]
                }
            }
        },
        "structs.ConsulGatewayBindAddress": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "port": {
                    "type": "integer"
                }
            }
        },
        "structs.ConsulGatewayProxy": {
            "type": "object",
            "properties": {
                "config": {
                    "type": "object",
                    "additionalProperties": true
                },
                "connectTimeout": {
                    "$ref": "#/definitions/time.Duration"
                },
                "envoyDNSDiscoveryType": {
                    "type": "string"
                },
                "envoyGatewayBindAddresses": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "#/definitions/structs.ConsulGatewayBindAddress"
                    }
                },
                "envoyGatewayBindTaggedAddresses": {
                    "type": "boolean"
                },
                "envoyGatewayNoDefaultBind": {
                    "type": "boolean"
                }
            }
        },
        "structs.ConsulGatewayTLSConfig": {
            "type": "object",
            "properties": {
                "cipherSuites": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "enabled": {
                    "type": "boolean"
                },
                "tlsmaxVersion": {
                    "type": "string"
                },
                "tlsminVersion": {
                    "type": "string"
                }
            }
        },
        "structs.ConsulIngressConfigEntry": {
            "type": "object",
            "properties": {
                "listeners": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.ConsulIngressListener"
                    }
                },
                "tls": {
                    "$ref": "#/definitions/structs.ConsulGatewayTLSConfig"
                }
            }
        },
        "structs.ConsulIngressListener": {
            "type": "object",
            "properties": {
                "port": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "string"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.ConsulIngressService"
                    }
                }
            }
        },
        "structs.ConsulIngressService": {
            "type": "object",
            "properties": {
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "structs.ConsulLinkedService": {
            "type": "object",
            "properties": {
                "cafile": {
                    "type": "string"
                },
                "certFile": {
                    "type": "string"
                },
                "keyFile": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "sni": {
                    "type": "string"
                }
            }
        },
        "structs.ConsulMeshConfigEntry": {
            "type": "object"
        },
        "structs.ConsulMeshGateway": {
            "type": "object",
            "properties": {
                "mode": {
                    "description": "Mode configures how an upstream should be accessed with regard to using\nmesh gateways.\n\nlocal - the connect proxy makes outbound connections through mesh gateway\noriginating in the same datacenter.\n\nremote - the connect proxy makes outbound connections to a mesh gateway\nin the destination datacenter.\n\nnone (default) - no mesh gateway is used, the proxy makes outbound connections\ndirectly to destination services.\n\nhttps://www.consul.io/docs/connect/gateways/mesh-gateway#modes-of-operation",
                    "type": "string"
                }
            }
        },
        "structs.ConsulProxy": {
            "type": "object",
            "properties": {
                "config": {
                    "description": "Config is a proxy configuration. It is opaque to Nomad and passed\ndirectly to Consul.",
                    "type": "object",
                    "additionalProperties": true
                },
                "expose": {
                    "description": "Expose configures the consul proxy.expose block to \"open up\" endpoints\nused by task-group level service checks using HTTP or gRPC protocols.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ConsulExposeConfig"
                        }
                    ]
                },
                "localServiceAddress": {
                    "description": "LocalServiceAddress is the address the local service binds to.\nUsually 127.0.0.1 it is useful to customize in clusters with mixed\nConnect and non-Connect services.",
                    "type": "string"
                },
                "localServicePort": {
                    "description": "LocalServicePort is the port the local service binds to. Usually\nthe same as the parent service's port, it is useful to customize\nin clusters with mixed Connect and non-Connect services",
                    "type": "integer"
                },
                "upstreams": {
                    "description": "Upstreams configures the upstream services this service intends to\nconnect to.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.ConsulUpstream"
                    }
                }
            }
        },
        "structs.ConsulSidecarService": {
            "type": "object",
            "properties": {
                "disableDefaultTCPCheck": {
                    "description": "DisableDefaultTCPCheck, if true, instructs Nomad to avoid setting a\ndefault TCP check for the sidecar service.",
                    "type": "boolean"
                },
                "meta": {
                    "description": "Meta specifies arbitrary KV metadata linked to the sidecar service.",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "port": {
                    "description": "Port is the service's port that the sidecar will connect to. May be\na port label or a literal port number.",
                    "type": "string"
                },
                "proxy": {
                    "description": "Proxy block defining the sidecar proxy configuration.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ConsulProxy"
                        }
                    ]
                },
                "tags": {
                    "description": "Tags are optional service tags that get registered with the sidecar service\nin Consul. If unset, the sidecar service inherits the parent service tags.",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "structs.ConsulTerminatingConfigEntry": {
            "type": "object",
            "properties": {
                "services": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.ConsulLinkedService"
                    }
                }
            }
        },
        "structs.ConsulUpstream": {
            "type": "object",
            "properties": {
                "config": {
                    "description": "Config is an upstream configuration. It is opaque to Nomad and passed\ndirectly to Consul.",
                    "type": "object",
                    "additionalProperties": {}
                },
                "datacenter": {
                    "description": "Datacenter is the datacenter in which to issue the discovery query to.",
                    "type": "string"
                },
                "destinationName": {
                    "description": "DestinationName is the name of the upstream service.",
                    "type": "string"
                },
                "destinationNamespace": {
                    "description": "DestinationNamespace is the namespace of the upstream service.",
                    "type": "string"
                },
                "destinationPeer": {
                    "description": "DestinationPeer the destination service address",
                    "type": "string"
                },
                "destinationType": {
                    "description": "DestinationType is the type of destination. It can be an IP address,\na DNS hostname, or a service name.",
                    "type": "string"
                },
                "localBindAddress": {
                    "description": "LocalBindAddress is the address the proxy will receive connections for the\nupstream on.",
                    "type": "string"
                },
                "localBindPort": {
                    "description": "LocalBindPort is the port the proxy will receive connections for the\nupstream on.",
                    "type": "integer"
                },
                "localBindSocketMode": {
                    "description": "LocalBindSocketMode defines access permissions to the local socket file",
                    "type": "string"
                },
                "localBindSocketPath": {
                    "description": "LocalBindSocketPath is the path of the local socket file that will be used\nto connect to the destination service",
                    "type": "string"
                },
                "meshGateway": {
                    "description": "MeshGateway is the optional configuration of the mesh gateway for this\nupstream to use.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ConsulMeshGateway"
                        }
                    ]
                }
            }
        },
        "structs.DNSConfig": {
            "type": "object",
            "properties": {
                "options": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "searches": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "servers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "structs.DispatchPayloadConfig": {
            "type": "object",
            "properties": {
                "file": {
                    "description": "File specifies a relative path to where the input data should be written",
                    "type": "string"
                }
            }
        },
        "structs.EphemeralDisk": {
            "type": "object",
            "properties": {
                "migrate": {
                    "description": "Migrate determines if Nomad client should migrate the allocation dir for\nsticky allocations",
                    "type": "boolean"
                },
                "sizeMB": {
                    "description": "SizeMB is the size of the local disk",
                    "type": "integer"
                },
                "sticky": {
                    "description": "Sticky indicates whether the allocation is sticky to a node",
                    "type": "boolean"
                }
            }
        },
        "structs.Job": {
            "type": "object",
            "properties": {
                "affinities": {
                    "description": "Affinities can be specified at the job level to express\nscheduling preferences that apply to all groups and tasks",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Affinity"
                    }
                },
                "allAtOnce": {
                    "description": "AllAtOnce is used to control if incremental scheduling of task groups\nis allowed or if we must do a gang scheduling of the entire job. This\ncan slow down larger jobs if resources are not available.",
                    "type": "boolean"
                },
                "constraints": {
                    "description": "Constraints can be specified at a job level and apply to\nall the task groups and tasks.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Constraint"
                    }
                },
                "consulNamespace": {
                    "description": "ConsulNamespace is the Consul namespace",
                    "type": "string"
                },
                "consulToken": {
                    "description": "ConsulToken is the Consul token that proves the submitter of the job has\naccess to the Service Identity policies associated with the job's\nConsul Connect enabled services. This field is only used to transfer the\ntoken and is not stored after Job submission.",
                    "type": "string"
                },
                "createIndex": {
                    "description": "Raft Indexes",
                    "type": "integer"
                },
                "datacenters": {
                    "description": "Datacenters contains all the datacenters this job is allowed to span",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "dispatchIdempotencyToken": {
                    "description": "DispatchIdempotencyToken is optionally used to ensure that a dispatched job does not have any\nnon-terminal siblings which have the same token value.",
                    "type": "string"
                },
                "dispatched": {
                    "description": "Dispatched is used to identify if the Job has been dispatched from a\nparameterized job.",
                    "type": "boolean"
                },
                "id": {
                    "description": "ID is a unique identifier for the job per region. It can be\nspecified hierarchically like LineOfBiz/OrgName/Team/Project",
                    "type": "string"
                },
                "jobModifyIndex": {
                    "type": "integer"
                },
                "meta": {
                    "description": "Meta is used to associate arbitrary metadata with this\njob. This is opaque to Nomad.",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "modifyIndex": {
                    "type": "integer"
                },
                "multiregion": {
                    "$ref": "#/definitions/structs.Multiregion"
                },
                "name": {
                    "description": "Name is the logical name of the job used to refer to it. This is unique\nper region, but not unique globally.",
                    "type": "string"
                },
                "namespace": {
                    "description": "Namespace is the namespace the job is submitted into.",
                    "type": "string"
                },
                "nodePool": {
                    "description": "NodePool specifies the node pool this job is allowed to run on.\n\nAn empty value is allowed during job registration, in which case the\nnamespace default node pool is used in Enterprise and the 'default' node\npool in OSS. But a node pool must be set before the job is stored, so\nthat will happen in the admission mutators.",
                    "type": "string"
                },
                "nomadTokenID": {
                    "description": "NomadTokenID is the Accessor ID of the ACL token (if any)\nused to register this version of the job. Used by deploymentwatcher.",
                    "type": "string"
                },
                "parameterizedJob": {
                    "description": "ParameterizedJob is used to specify the job as a parameterized job\nfor dispatching.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ParameterizedJobConfig"
                        }
                    ]
                },
                "parentID": {
                    "description": "ParentID is the unique identifier of the job that spawned this job.",
                    "type": "string"
                },
                "payload": {
                    "description": "Payload is the payload supplied when the job was dispatched.",
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "periodic": {
                    "description": "Periodic is used to define the interval the job is run at.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.PeriodicConfig"
                        }
                    ]
                },
                "priority": {
                    "description": "Priority is used to control scheduling importance and if this job\ncan preempt other jobs.",
                    "type": "integer"
                },
                "region": {
                    "description": "Region is the Nomad region that handles scheduling this job",
                    "type": "string"
                },
                "spreads": {
                    "description": "Spread can be specified at the job level to express spreading\nallocations across a desired attribute, such as datacenter",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Spread"
                    }
                },
                "stable": {
                    "description": "Stable marks a job as stable. Stability is only defined on \"service\" and\n\"system\" jobs. The stability of a job will be set automatically as part\nof a deployment and can be manually set via APIs. This field is updated\nwhen the status of a corresponding deployment transitions to Failed\nor Successful. This field is not meaningful for jobs that don't have an\nupdate block.",
                    "type": "boolean"
                },
                "status": {
                    "description": "Job status",
                    "type": "string"
                },
                "statusDescription": {
                    "description": "StatusDescription is meant to provide more human useful information",
                    "type": "string"
                },
                "stop": {
                    "description": "Stop marks whether the user has stopped the job. A stopped job will\nhave all created allocations stopped and acts as a way to stop a job\nwithout purging it from the system. This allows existing allocs to be\nqueried and the job to be inspected as it is being killed.",
                    "type": "boolean"
                },
                "submitTime": {
                    "description": "SubmitTime is the time at which the job version was submitted as\nUnixNano in UTC",
                    "type": "integer"
                },
                "taskGroups": {
                    "description": "TaskGroups are the collections of task groups that this job needs\nto run. Each task group is an atomic unit of scheduling and placement.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.TaskGroup"
                    }
                },
                "type": {
                    "description": "Type is used to control various behaviors about the job. Most jobs\nare service jobs, meaning they are expected to be long lived.\nSome jobs are batch oriented meaning they run and then terminate.\nThis can be extended in the future to support custom schedulers.",
                    "type": "string"
                },
                "update": {
                    "description": "See agent.ApiJobToStructJob\nUpdate provides defaults for the TaskGroup Update blocks",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.UpdateStrategy"
                        }
                    ]
                },
                "vaultNamespace": {
                    "description": "VaultNamespace is the Vault namespace",
                    "type": "string"
                },
                "vaultToken": {
                    "description": "VaultToken is the Vault token that proves the submitter of the job has\naccess to the specified Vault policies. This field is only used to\ntransfer the token and is not stored after Job submission.",
                    "type": "string"
                },
                "version": {
                    "description": "Version is a monotonically increasing version number that is incremented\non each job register.",
                    "type": "integer"
                }
            }
        },
        "structs.JobChildrenSummary": {
            "type": "object",
            "properties": {
                "dead": {
                    "type": "integer"
                },
                "pending": {
                    "type": "integer"
                },
                "running": {
                    "type": "integer"
                }
            }
        },
        "structs.JobListStub": {
            "type": "object",
            "properties": {
                "createIndex": {
                    "type": "integer"
                },
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "id": {
                    "type": "string"
                },
                "jobModifyIndex": {
                    "type": "integer"
                },
                "jobSummary": {
                    "$ref": "#/definitions/structs.JobSummary"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "modifyIndex": {
                    "type": "integer"
                },
                "multiregion": {
                    "$ref": "#/definitions/structs.Multiregion"
                },
                "name": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "nodePool": {
                    "type": "string"
                },
                "parameterizedJob": {
                    "type": "boolean"
                },
                "parentID": {
                    "type": "string"
                },
                "periodic": {
                    "type": "boolean"
                },
                "priority": {
                    "type": "integer"
                },
                "status": {
                    "type": "string"
                },
                "statusDescription": {
                    "type": "string"
                },
                "stop": {
                    "type": "boolean"
                },
                "submitTime": {
                    "type": "integer"
                },
                "type": {
                    "type": "string"
                }
            }
        },
        "structs.JobSummary": {
            "type": "object",
            "properties": {
                "children": {
                    "description": "Children contains a summary for the children of this job.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.JobChildrenSummary"
                        }
                    ]
                },
                "createIndex": {
                    "description": "Raft Indexes",
                    "type": "integer"
                },
                "jobID": {
                    "description": "JobID is the ID of the job the summary is for",
                    "type": "string"
                },
                "modifyIndex": {
                    "type": "integer"
                },
                "namespace": {
                    "description": "Namespace is the namespace of the job and its summary",
                    "type": "string"
                },
                "summary": {
                    "description": "Summary contains the summary per task group for the Job",
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "#/definitions/structs.TaskGroupSummary"
                    }
                }
            }
        },
        "structs.LogConfig": {
            "type": "object",
            "properties": {
                "disabled": {
                    "type": "boolean"
                },
                "maxFileSizeMB": {
                    "type": "integer"
                },
                "maxFiles": {
                    "type": "integer"
                }
            }
        },
        "structs.MigrateStrategy": {
            "type": "object",
            "properties": {
                "healthCheck": {
                    "type": "string"
                },
                "healthyDeadline": {
                    "$ref": "#/definitions/time.Duration"
                },
                "maxParallel": {
                    "type": "integer"
                },
                "minHealthyTime": {
                    "$ref": "#/definitions/time.Duration"
                }
            }
        },
        "structs.Multiregion": {
            "type": "object",
            "properties": {
                "regions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.MultiregionRegion"
                    }
                },
                "strategy": {
                    "$ref": "#/definitions/structs.MultiregionStrategy"
                }
            }
        },
        "structs.MultiregionRegion": {
            "type": "object",
            "properties": {
                "count": {
                    "type": "integer"
                },
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "nodePool": {
                    "type": "string"
                }
            }
        },
        "structs.MultiregionStrategy": {
            "type": "object",
            "properties": {
                "maxParallel": {
                    "type": "integer"
                },
                "onFailure": {
                    "type": "string"
                }
            }
        },
        "structs.NUMA": {
            "type": "object",
            "properties": {
                "affinity": {
                    "description": "Affinity is the numa affinity scheduling behavior.\nOne of \"none\", \"prefer\", \"require\".",
                    "type": "string"
                }
            }
        },
        "structs.NetworkResource": {
            "type": "object",
            "properties": {
                "cidr": {
                    "description": "CIDR block of addresses",
                    "type": "string"
                },
                "device": {
                    "description": "Name of the device",
                    "type": "string"
                },
                "dns": {
                    "description": "DNS Configuration",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.DNSConfig"
                        }
                    ]
                },
                "dynamicPorts": {
                    "description": "Host Dynamically assigned ports",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Port"
                    }
                },
                "hostname": {
                    "description": "Hostname of the network namespace",
                    "type": "string"
                },
                "ip": {
                    "description": "Host IP address",
                    "type": "string"
                },
                "mbits": {
                    "description": "Throughput",
                    "type": "integer"
                },
                "mode": {
                    "description": "Mode of the network",
                    "type": "string"
                },
                "reservedPorts": {
                    "description": "Host Reserved ports",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Port"
                    }
                }
            }
        },
        "structs.ParameterizedJobConfig": {
            "type": "object",
            "properties": {
                "metaOptional": {
                    "description": "MetaOptional is metadata keys that may be specified by the dispatcher",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "metaRequired": {
                    "description": "MetaRequired is metadata keys that must be specified by the dispatcher",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "payload": {
                    "description": "Payload configure the payload requirements",
                    "type": "string"
                }
            }
        },
        "structs.PeriodicConfig": {
            "type": "object",
            "properties": {
                "enabled": {
                    "description": "Enabled determines if the job should be run periodically.",
                    "type": "boolean"
                },
                "prohibitOverlap": {
                    "description": "ProhibitOverlap enforces that spawned jobs do not run in parallel.",
                    "type": "boolean"
                },
                "spec": {
                    "description": "Spec specifies the interval the job should be run as. It is parsed based\non the SpecType.",
                    "type": "string"
                },
                "specType": {
                    "description": "SpecType defines the format of the spec.",
                    "type": "string"
                },
                "specs": {
                    "description": "Specs specifies the intervals the job should be run as. It is parsed based\non the SpecType.",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "timeZone": {
                    "description": "TimeZone is the user specified string that determines the time zone to\nlaunch against. The time zones must be specified from IANA Time Zone\ndatabase, such as \"America/New_York\".\nReference: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\nReference: https://www.iana.org/time-zones",
                    "type": "string"
                }
            }
        },
        "structs.Port": {
            "type": "object",
            "properties": {
                "hostNetwork": {
                    "description": "HostNetwork is the name of the network this port should be assigned\nto. Jobs with a HostNetwork set can only be placed on nodes with\nthat host network available.",
                    "type": "string"
                },
                "label": {
                    "description": "Label is the key for HCL port blocks: port \"foo\" {}",
                    "type": "string"
                },
                "to": {
                    "description": "To is the port inside a network namespace where this port is\nforwarded. -1 is an internal sentinel value used by Consul Connect\nto mean \"same as the host port.\"",
                    "type": "integer"
                },
                "value": {
                    "description": "Value is the static or dynamic port value. For dynamic ports this\nwill be 0 in the jobspec and set by the scheduler.",
                    "type": "integer"
                }
            }
        },
        "structs.RequestedDevice": {
            "type": "object",
            "properties": {
                "affinities": {
                    "description": "Affinities are a set of affinities to apply when selecting the device\nto use.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Affinity"
                    }
                },
                "constraints": {
                    "description": "Constraints are a set of constraints to apply when selecting the device\nto use.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Constraint"
                    }
                },
                "count": {
                    "description": "Count is the number of requested devices",
                    "type": "integer"
                },
                "name": {
                    "description": "Name is the request name. The possible values are as follows:\n* \u003ctype\u003e: A single value only specifies the type of request.\n* \u003cvendor\u003e/\u003ctype\u003e: A single slash delimiter assumes the vendor and type of device is specified.\n* \u003cvendor\u003e/\u003ctype\u003e/\u003cname\u003e: Two slash delimiters assume vendor, type and specific model are specified.\n\nExamples are as follows:\n* \"gpu\"\n* \"nvidia/gpu\"\n* \"nvidia/gpu/GTX2080Ti\"",
                    "type": "string"
                }
            }
        },
        "structs.ReschedulePolicy": {
            "type": "object",
            "properties": {
                "attempts": {
                    "description": "Attempts limits the number of rescheduling attempts that can occur in an interval.",
                    "type": "integer"
                },
                "delay": {
                    "description": "Delay is a minimum duration to wait between reschedule attempts.\nThe delay function determines how much subsequent reschedule attempts are delayed by.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "delayFunction": {
                    "description": "DelayFunction determines how the delay progressively changes on subsequent reschedule\nattempts. Valid values are \"exponential\", \"constant\", and \"fibonacci\".",
                    "type": "string"
                },
                "interval": {
                    "description": "Interval is a duration in which we can limit the number of reschedule attempts.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "maxDelay": {
                    "description": "MaxDelay is an upper bound on the delay.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "unlimited": {
                    "description": "Unlimited allows infinite rescheduling attempts. Only allowed when delay is set\nbetween reschedule attempts.",
                    "type": "boolean"
                }
            }
        },
        "structs.Resources": {
            "type": "object",
            "properties": {
                "cores": {
                    "type": "integer"
                },
                "cpu": {
                    "type": "integer"
                },
                "devices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.RequestedDevice"
                    }
                },
                "diskMB": {
                    "type": "integer"
                },
                "iops": {
                    "description": "COMPAT(0.10): Only being used to issue warnings",
                    "type": "integer"
                },
                "memoryMB": {
                    "type": "integer"
                },
                "memoryMaxMB": {
                    "type": "integer"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.NetworkResource"
                    }
                },
                "numa": {
                    "$ref": "#/definitions/structs.NUMA"
                }
            }
        },
        "structs.RestartPolicy": {
            "type": "object",
            "properties": {
                "attempts": {
                    "description": "Attempts is the number of restart that will occur in an interval.",
                    "type": "integer"
                },
                "delay": {
                    "description": "Delay is the time between a failure and a restart.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "interval": {
                    "description": "Interval is a duration in which we can limit the number of restarts\nwithin.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "mode": {
                    "description": "Mode controls what happens when the task restarts more than attempt times\nin an interval.",
                    "type": "string"
                },
                "renderTemplates": {
                    "description": "RenderTemplates is flag to explicitly render all templates on task restart",
                    "type": "boolean"
                }
            }
        },
        "structs.ScalingPolicy": {
            "type": "object",
            "properties": {
                "createIndex": {
                    "type": "integer"
                },
                "enabled": {
                    "description": "Enabled indicates whether this policy has been enabled/disabled",
                    "type": "boolean"
                },
                "id": {
                    "description": "ID is a generated UUID used for looking up the scaling policy",
                    "type": "string"
                },
                "max": {
                    "description": "Max is the maximum allowable scaling count for this target",
                    "type": "integer"
                },
                "min": {
                    "description": "Min is the minimum allowable scaling count for this target",
                    "type": "integer"
                },
                "modifyIndex": {
                    "type": "integer"
                },
                "policy": {
                    "description": "Policy is an opaque description of the scaling policy, passed to the autoscaler",
                    "type": "object",
                    "additionalProperties": true
                },
                "target": {
                    "description": "Target contains information about the target of the scaling policy, like job and group",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "type": {
                    "description": "Type is the type of scaling performed by the policy",
                    "type": "string"
                }
            }
        },
        "structs.Service": {
            "type": "object",
            "properties": {
                "address": {
                    "description": "Address enables explicitly setting a custom address to use in service\nregistration. AddressMode must be \"auto\" if Address is set.",
                    "type": "string"
                },
                "addressMode": {
                    "description": "AddressMode specifies how the address in service registration is\ndetermined. Must be \"auto\" (default), \"host\", \"driver\", or \"alloc\".",
                    "type": "string"
                },
                "canaryMeta": {
                    "description": "Consul service meta when it is a canary",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "canaryTags": {
                    "description": "List of tags for the service when it is a canary",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "checks": {
                    "description": "List of checks associated with the service",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.ServiceCheck"
                    }
                },
                "cluster": {
                    "description": "Consul Cluster (by name) to send API requests to",
                    "type": "string"
                },
                "connect": {
                    "description": "Consul Connect configuration",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ConsulConnect"
                        }
                    ]
                },
                "enableTagOverride": {
                    "description": "EnableTagOverride will disable Consul's anti-entropy mechanism for the\ntags of this service. External updates to the service definition via\nConsul will not be corrected to match the service definition set in the\nNomad job specification.\n\nhttps://www.consul.io/docs/agent/services.html#service-definition",
                    "type": "boolean"
                },
                "identity": {
                    "description": "Identity is a field populated automatically by the job mutating hook.\nIts name will be ` + "`" + `consul-service/${service_name}` + "`" + `, and its contents will\nmatch the server's ` + "`" + `consul.service_identity` + "`" + ` configuration block.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.WorkloadIdentity"
                        }
                    ]
                },
                "meta": {
                    "description": "Consul service meta",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "description": "Name of the service registered with Consul. Consul defaults the\nName to ServiceID if not specified.  The Name if specified is used\nas one of the seed values when generating a Consul ServiceID.",
                    "type": "string"
                },
                "namespace": {
                    "description": "The consul namespace in which this service will be registered. Namespace\nat the service.check level is not part of the Nomad API - it must be\nset at the job or group level. This field is managed internally so\nthat Hash can work correctly.",
                    "type": "string"
                },
                "onUpdate": {
                    "description": "OnUpdate Specifies how the service and its checks should be evaluated\nduring an update",
                    "type": "string"
                },
                "portLabel": {
                    "description": "PortLabel is either the numeric port number or the ` + "`" + `host:port` + "`" + `.\nTo specify the port number using the host's Consul Advertise\naddress, specify an empty host in the PortLabel (e.g. ` + "`" + `:port` + "`" + `).",
                    "type": "string"
                },
                "provider": {
                    "description": "Provider dictates which service discovery provider to use. This can be\neither ServiceProviderConsul or ServiceProviderNomad and defaults to the former when\nleft empty by the operator.",
                    "type": "string"
                },
                "taggedAddresses": {
                    "description": "The values to set for tagged_addresses in Consul service registration.\nDoes not affect Nomad networking, these are for Consul service discovery.",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "tags": {
                    "description": "List of tags for the service",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "taskName": {
                    "description": "Name of the Task associated with this service.\nGroup services do not have a task name, unless they are a connect native\nservice specifying the task implementing the service.\nTask-level services automatically have the task name plumbed through\ndown to checks for convenience.",
                    "type": "string"
                }
            }
        },
        "structs.ServiceCheck": {
            "type": "object",
            "properties": {
                "addressMode": {
                    "description": "Must be empty, \"alloc\", \"host\", or \"driver\"",
                    "type": "string"
                },
                "args": {
                    "description": "Args is a list of arguments for script checks",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "body": {
                    "description": "Body to use in HTTP check",
                    "type": "string"
                },
                "checkRestart": {
                    "description": "If and when a task should be restarted based on checks",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.CheckRestart"
                        }
                    ]
                },
                "command": {
                    "description": "Command is the command to run for script checks",
                    "type": "string"
                },
                "expose": {
                    "description": "Whether to have Envoy expose the check path (connect-enabled group-services only)",
                    "type": "boolean"
                },
                "failuresBeforeCritical": {
                    "description": "Number of consecutive failures required before considered unhealthy",
                    "type": "integer"
                },
                "failuresBeforeWarning": {
                    "description": "Number of consecutive failures required before showing warning",
                    "type": "integer"
                },
                "grpcservice": {
                    "description": "Service for GRPC checks",
                    "type": "string"
                },
                "grpcuseTLS": {
                    "description": "Whether or not to use TLS for GRPC checks",
                    "type": "boolean"
                },
                "header": {
                    "description": "HTTP Headers for Consul to set when making HTTP checks",
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "initialStatus": {
                    "description": "Initial status of the check",
                    "type": "string"
                },
                "interval": {
                    "description": "Interval of the check",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "method": {
                    "description": "HTTP Method to use (GET by default)",
                    "type": "string"
                },
                "name": {
                    "description": "Name of the check, defaults to a generated label",
                    "type": "string"
                },
                "onUpdate": {
                    "type": "string"
                },
                "path": {
                    "description": "path of the health check url for http type check",
                    "type": "string"
                },
                "portLabel": {
                    "description": "The port to use for tcp/http checks",
                    "type": "string"
                },
                "protocol": {
                    "description": "Protocol to use if check is http, defaults to http",
                    "type": "string"
                },
                "successBeforePassing": {
                    "description": "Number of consecutive successes required before considered healthy",
                    "type": "integer"
                },
                "taskName": {
                    "description": "What task to execute this check in",
                    "type": "string"
                },
                "timeout": {
                    "description": "Timeout of the response from the check before consul fails the check",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "tlsserverName": {
                    "description": "ServerName to use for SNI and TLS verification when (Type=https and Protocol=https) or (Type=grpc and GRPCUseTLS=true)",
                    "type": "string"
                },
                "tlsskipVerify": {
                    "description": "Skip TLS verification when (type=https and Protocol=https) or (type=grpc and grpc_use_tls=true)",
                    "type": "boolean"
                },
                "type": {
                    "description": "Type of the check - tcp, http, docker and script",
                    "type": "string"
                }
            }
        },
        "structs.SidecarTask": {
            "type": "object",
            "properties": {
                "config": {
                    "description": "Config is provided to the driver to initialize",
                    "type": "object",
                    "additionalProperties": true
                },
                "driver": {
                    "description": "Driver is used to control which driver is used",
                    "type": "string"
                },
                "env": {
                    "description": "Map of environment variables to be used by the driver",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "killSignal": {
                    "description": "KillSignal is the kill signal to use for the task. This is an optional\nspecification and defaults to SIGINT",
                    "type": "string"
                },
                "killTimeout": {
                    "description": "KillTimeout is the time between signaling a task that it will be\nkilled and killing it.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "logConfig": {
                    "description": "LogConfig provides configuration for log rotation",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.LogConfig"
                        }
                    ]
                },
                "meta": {
                    "description": "Meta is used to associate arbitrary metadata with this\ntask. This is opaque to Nomad.",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "description": "Name of the task",
                    "type": "string"
                },
                "resources": {
                    "description": "Resources is the resources needed by this task",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.Resources"
                        }
                    ]
                },
                "shutdownDelay": {
                    "description": "ShutdownDelay is the duration of the delay between deregistering a\ntask from Consul and sending it a signal to shutdown. See #2441",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "user": {
                    "description": "User is used to determine which user will run the task. It defaults to\nthe same user the Nomad client is being run as.",
                    "type": "string"
                }
            }
        },
        "structs.Spread": {
            "type": "object",
            "properties": {
                "attribute": {
                    "description": "Attribute is the node attribute used as the spread criteria",
                    "type": "string"
                },
                "spreadTarget": {
                    "description": "SpreadTarget is used to describe desired percentages for each attribute value",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.SpreadTarget"
                    }
                },
                "weight": {
                    "description": "Weight is the relative weight of this spread, useful when there are multiple\nspread and affinities",
                    "type": "integer"
                }
            }
        },
        "structs.SpreadTarget": {
            "type": "object",
            "properties": {
                "percent": {
                    "description": "Percent is the desired percentage of allocs",
                    "type": "integer"
                },
                "value": {
                    "description": "Value is a single attribute value, like \"dc1\"",
                    "type": "string"
                }
            }
        },
        "structs.Task": {
            "type": "object",
            "properties": {
                "actions": {
                    "description": "Alloc-exec-like runnable commands",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Action"
                    }
                },
                "affinities": {
                    "description": "Affinities can be specified at the task level to express\nscheduling preferences",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Affinity"
                    }
                },
                "artifacts": {
                    "description": "Artifacts is a list of artifacts to download and extract before running\nthe task.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.TaskArtifact"
                    }
                },
                "config": {
                    "description": "Config is provided to the driver to initialize",
                    "type": "object",
                    "additionalProperties": true
                },
                "constraints": {
                    "description": "Constraints can be specified at a task level and apply only to\nthe particular task.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Constraint"
                    }
                },
                "consul": {
                    "description": "Consul configuration specific to this task. If uset, falls back to the\ngroup's Consul field.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.Consul"
                        }
                    ]
                },
                "csipluginConfig": {
                    "description": "CSIPluginConfig is used to configure the plugin supervisor for the task.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.TaskCSIPluginConfig"
                        }
                    ]
                },
                "dispatchPayload": {
                    "description": "DispatchPayload configures how the task retrieves its input from a dispatch",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.DispatchPayloadConfig"
                        }
                    ]
                },
                "driver": {
                    "description": "Driver is used to control which driver is used",
                    "type": "string"
                },
                "env": {
                    "description": "Map of environment variables to be used by the driver",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "identities": {
                    "description": "Identities are the alternate workload identities for use with 3rd party\nendpoints.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.WorkloadIdentity"
                    }
                },
                "identity": {
                    "description": "Identity is the default Nomad Workload Identity.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.WorkloadIdentity"
                        }
                    ]
                },
                "killSignal": {
                    "description": "KillSignal is the kill signal to use for the task. This is an optional\nspecification and defaults to SIGINT",
                    "type": "string"
                },
                "killTimeout": {
                    "description": "KillTimeout is the time between signaling a task that it will be\nkilled and killing it.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "kind": {
                    "description": "Used internally to manage tasks according to their TaskKind. Initial use case\nis for Consul Connect",
                    "type": "string"
                },
                "leader": {
                    "description": "Leader marks the task as the leader within the group. When the leader\ntask exits, other tasks will be gracefully terminated.",
                    "type": "boolean"
                },
                "lifecycle": {
                    "$ref": "#/definitions/structs.TaskLifecycleConfig"
                },
                "logConfig": {
                    "description": "LogConfig provides configuration for log rotation",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.LogConfig"
                        }
                    ]
                },
                "meta": {
                    "description": "Meta is used to associate arbitrary metadata with this\ntask. This is opaque to Nomad.",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "description": "Name of the task",
                    "type": "string"
                },
                "resources": {
                    "description": "Resources is the resources needed by this task",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.Resources"
                        }
                    ]
                },
                "restartPolicy": {
                    "description": "RestartPolicy of a TaskGroup",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.RestartPolicy"
                        }
                    ]
                },
                "scalingPolicies": {
                    "description": "ScalingPolicies is a list of scaling policies scoped to this task",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.ScalingPolicy"
                    }
                },
                "services": {
                    "description": "List of service definitions exposed by the Task",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Service"
                    }
                },
                "shutdownDelay": {
                    "description": "ShutdownDelay is the duration of the delay between de-registering a\ntask from Consul and sending it a signal to shutdown. See #2441",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "templates": {
                    "description": "Templates are the set of templates to be rendered for the task.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Template"
                    }
                },
                "user": {
                    "description": "User is used to determine which user will run the task. It defaults to\nthe same user the Nomad client is being run as.",
                    "type": "string"
                },
                "vault": {
                    "description": "Vault is used to define the set of Vault policies that this task should\nhave access to.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.Vault"
                        }
                    ]
                },
                "volumeMounts": {
                    "description": "VolumeMounts is a list of Volume name \u003c-\u003e mount configurations that will be\nattached to this task.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.VolumeMount"
                    }
                }
            }
        },
        "structs.TaskArtifact": {
            "type": "object",
            "properties": {
                "getterHeaders": {
                    "description": "GetterHeaders are headers to use when downloading the artifact using\ngo-getter.",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "getterMode": {
                    "description": "GetterMode is the go-getter.ClientMode for fetching resources.\nDefaults to \"any\" but can be set to \"file\" or \"dir\".",
                    "type": "string"
                },
                "getterOptions": {
                    "description": "GetterOptions are options to use when downloading the artifact using\ngo-getter.",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "getterSource": {
                    "description": "GetterSource is the source to download an artifact using go-getter",
                    "type": "string"
                },
                "relativeDest": {
                    "description": "RelativeDest is the download destination given relative to the task's\ndirectory.",
                    "type": "string"
                }
            }
        },
        "structs.TaskCSIPluginConfig": {
            "type": "object",
            "properties": {
                "healthTimeout": {
                    "description": "HealthTimeout is the time after which the CSI plugin tasks will be killed\nif the CSI Plugin is not healthy.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "id": {
                    "description": "ID is the identifier of the plugin.\nIdeally this should be the FQDN of the plugin.",
                    "type": "string"
                },
                "mountDir": {
                    "description": "MountDir is the directory (within its container) in which the plugin creates a\nsocket (called CSISocketName) for communication with Nomad. Default is /csi.",
                    "type": "string"
                },
                "stagePublishBaseDir": {
                    "description": "StagePublishBaseDir is the base directory (within its container) in which the plugin\nmounts volumes being staged and bind mount volumes being published.\ne.g. staging_target_path = {StagePublishBaseDir}/staging/{volume-id}/{usage-mode}\ne.g. target_path = {StagePublishBaseDir}/per-alloc/{alloc-id}/{volume-id}/{usage-mode}\nDefault is /local/csi.",
                    "type": "string"
                },
                "type": {
                    "description": "Type instructs Nomad on how to handle processing a plugin",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.CSIPluginType"
                        }
                    ]
                }
            }
        },
        "structs.TaskGroup": {
            "type": "object",
            "properties": {
                "affinities": {
                    "description": "Affinities can be specified at the task group level to express\nscheduling preferences.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Affinity"
                    }
                },
                "constraints": {
                    "description": "Constraints can be specified at a task group level and apply to\nall the tasks contained.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Constraint"
                    }
                },
                "consul": {
                    "description": "Consul configuration specific to this task group",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.Consul"
                        }
                    ]
                },
                "count": {
                    "description": "Count is the number of replicas of this task group that should\nbe scheduled.",
                    "type": "integer"
                },
                "ephemeralDisk": {
                    "description": "EphemeralDisk is the disk resources that the task group requests",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.EphemeralDisk"
                        }
                    ]
                },
                "maxClientDisconnect": {
                    "description": "MaxClientDisconnect, if set, configures the client to allow placed\nallocations for tasks in this group to attempt to resume running without a restart.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "meta": {
                    "description": "Meta is used to associate arbitrary metadata with this\ntask group. This is opaque to Nomad.",
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "migrate": {
                    "description": "Migrate is used to control the migration strategy for this task group",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.MigrateStrategy"
                        }
                    ]
                },
                "name": {
                    "description": "Name of the task group",
                    "type": "string"
                },
                "networks": {
                    "description": "Networks are the network configuration for the task group. This can be\noverridden in the task.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.NetworkResource"
                    }
                },
                "preventRescheduleOnLost": {
                    "description": "PreventRescheduleOnLost is used to signal that an allocation should not\nbe rescheduled if its node goes down or is disconnected.",
                    "type": "boolean"
                },
                "reschedulePolicy": {
                    "description": "ReschedulePolicy is used to configure how the scheduler should\nretry failed allocations.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ReschedulePolicy"
                        }
                    ]
                },
                "restartPolicy": {
                    "description": "RestartPolicy of a TaskGroup",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.RestartPolicy"
                        }
                    ]
                },
                "scaling": {
                    "description": "Scaling is the list of autoscaling policies for the TaskGroup",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ScalingPolicy"
                        }
                    ]
                },
                "services": {
                    "description": "Services this group provides",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Service"
                    }
                },
                "shutdownDelay": {
                    "description": "ShutdownDelay is the amount of time to wait between deregistering\ngroup services in consul and stopping tasks.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "spreads": {
                    "description": "Spread can be specified at the task group level to express spreading\nallocations across a desired attribute, such as datacenter",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Spread"
                    }
                },
                "stopAfterClientDisconnect": {
                    "description": "StopAfterClientDisconnect, if set, configures the client to stop the task group\nafter this duration since the last known good heartbeat",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "tasks": {
                    "description": "Tasks are the collection of tasks that this task group needs to run",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/structs.Task"
                    }
                },
                "update": {
                    "description": "Update is used to control the update strategy for this task group",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.UpdateStrategy"
                        }
                    ]
                },
                "volumes": {
                    "description": "Volumes is a map of volumes that have been requested by the task group.",
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "#/definitions/structs.VolumeRequest"
                    }
                }
            }
        },
        "structs.TaskGroupSummary": {
            "type": "object",
            "properties": {
                "complete": {
                    "type": "integer"
                },
                "failed": {
                    "type": "integer"
                },
                "lost": {
                    "type": "integer"
                },
                "queued": {
                    "type": "integer"
                },
                "running": {
                    "type": "integer"
                },
                "starting": {
                    "type": "integer"
                },
                "unknown": {
                    "type": "integer"
                }
            }
        },
        "structs.TaskLifecycleConfig": {
            "type": "object",
            "properties": {
                "hook": {
                    "type": "string"
                },
                "sidecar": {
                    "type": "boolean"
                }
            }
        },
        "structs.Template": {
            "type": "object",
            "properties": {
                "changeMode": {
                    "description": "ChangeMode indicates what should be done if the template is re-rendered",
                    "type": "string"
                },
                "changeScript": {
                    "description": "ChangeScript is the configuration of the script. It's required if\nChangeMode is set to script.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.ChangeScript"
                        }
                    ]
                },
                "changeSignal": {
                    "description": "ChangeSignal is the signal that should be sent if the change mode\nrequires it.",
                    "type": "string"
                },
                "destPath": {
                    "description": "DestPath is the path to where the template should be rendered",
                    "type": "string"
                },
                "embeddedTmpl": {
                    "description": "EmbeddedTmpl store the raw template. This is useful for smaller templates\nwhere they are embedded in the job file rather than sent as an artifact",
                    "type": "string"
                },
                "envvars": {
                    "description": "Envvars enables exposing the template as environment variables\ninstead of as a file. The template must be of the form:\n\n\tVAR_NAME_1={{ key service/my-key }}\n\tVAR_NAME_2=raw string and {{ env \"attr.kernel.name\" }}\n\nLines will be split on the initial \"=\" with the first part being the\nkey name and the second part the value.\nEmpty lines and lines starting with # will be ignored, but to avoid\nescaping issues #s within lines will not be treated as comments.",
                    "type": "boolean"
                },
                "errMissingKey": {
                    "description": "ErrMissingKey is used to control how the template behaves when attempting\nto index a struct or map key that does not exist.",
                    "type": "boolean"
                },
                "gid": {
                    "type": "integer"
                },
                "leftDelim": {
                    "description": "LeftDelim and RightDelim are optional configurations to control what\ndelimiter is utilized when parsing the template.",
                    "type": "string"
                },
                "perms": {
                    "description": "Perms is the permission the file should be written out with.",
                    "type": "string"
                },
                "rightDelim": {
                    "type": "string"
                },
                "sourcePath": {
                    "description": "SourcePath is the path to the template to be rendered",
                    "type": "string"
                },
                "splay": {
                    "description": "Splay is used to avoid coordinated restarts of processes by applying a\nrandom wait between 0 and the given splay value before signalling the\napplication of a change",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "uid": {
                    "description": "User and group that should own the file.",
                    "type": "integer"
                },
                "vaultGrace": {
                    "description": "VaultGrace is the grace duration between lease renewal and reacquiring a\nsecret. If the lease of a secret is less than the grace, a new secret is\nacquired.\nCOMPAT(0.12) VaultGrace has been ignored by Vault since Vault v0.5.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "wait": {
                    "description": "WaitConfig is used to override the global WaitConfig on a per-template basis",
                    "allOf": [
                        {
                            "$ref": "#/definitions/structs.WaitConfig"
                        }
                    ]
                }
            }
        },
        "structs.UpdateStrategy": {
            "type": "object",
            "properties": {
                "autoPromote": {
                    "description": "AutoPromote declares that the deployment should be promoted when all canaries are\nhealthy",
                    "type": "boolean"
                },
                "autoRevert": {
                    "description": "AutoRevert declares that if a deployment fails because of unhealthy\nallocations, there should be an attempt to auto-revert the job to a\nstable version.",
                    "type": "boolean"
                },
                "canary": {
                    "description": "Canary is the number of canaries to deploy when a change to the task\ngroup is detected.",
                    "type": "integer"
                },
                "healthCheck": {
                    "description": "HealthCheck specifies the mechanism in which allocations are marked\nhealthy or unhealthy as part of a deployment.",
                    "type": "string"
                },
                "healthyDeadline": {
                    "description": "HealthyDeadline is the time in which an allocation must be marked as\nhealthy before it is automatically transitioned to unhealthy. This time\nperiod doesn't count against the MinHealthyTime.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "maxParallel": {
                    "description": "MaxParallel is how many updates can be done in parallel",
                    "type": "integer"
                },
                "minHealthyTime": {
                    "description": "MinHealthyTime is the minimum time an allocation must be in the healthy\nstate before it is marked as healthy, unblocking more allocations to be\nrolled.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "progressDeadline": {
                    "description": "ProgressDeadline is the time in which an allocation as part of the\ndeployment must transition to healthy. If no allocation becomes healthy\nafter the deadline, the deployment is marked as failed. If the deadline\nis zero, the first failure causes the deployment to fail.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                },
                "stagger": {
                    "description": "Stagger is used to determine the rate at which allocations are migrated\ndue to down or draining nodes.",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                }
            }
        },
        "structs.Vault": {
            "type": "object",
            "properties": {
                "allowTokenExpiration": {
                    "description": "AllowTokenExpiration disables the Vault token refresh loop on the client",
                    "type": "boolean"
                },
                "changeMode": {
                    "description": "ChangeMode is used to configure the task's behavior when the Vault\ntoken changes because the original token could not be renewed in time.",
                    "type": "string"
                },
                "changeSignal": {
                    "description": "ChangeSignal is the signal sent to the task when a new token is\nretrieved. This is only valid when using the signal change mode.",
                    "type": "string"
                },
                "cluster": {
                    "description": "Cluster (by name) to send API requests to",
                    "type": "string"
                },
                "disableFile": {
                    "description": "DisableFile marks whether the Vault Token should be exposed in the file\nvault_token in the task's secrets directory.",
                    "type": "boolean"
                },
                "env": {
                    "description": "Env marks whether the Vault Token should be exposed as an environment\nvariable",
                    "type": "boolean"
                },
                "namespace": {
                    "description": "Namespace is the vault namespace that should be used.",
                    "type": "string"
                },
                "policies": {
                    "description": "Policies is the set of policies that the task needs access to",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "role": {
                    "description": "Role is the Vault role used to login to Vault using a JWT.\n\nIf empty, defaults to the server's create_from_role value or the Vault\ncluster default role.",
                    "type": "string"
                }
            }
        },
        "structs.VolumeMount": {
            "type": "object",
            "properties": {
                "destination": {
                    "type": "string"
                },
                "propagationMode": {
                    "type": "string"
                },
                "readOnly": {
                    "type": "boolean"
                },
                "volume": {
                    "type": "string"
                }
            }
        },
        "structs.VolumeRequest": {
            "type": "object",
            "properties": {
                "accessMode": {
                    "$ref": "#/definitions/structs.CSIVolumeAccessMode"
                },
                "attachmentMode": {
                    "$ref": "#/definitions/structs.CSIVolumeAttachmentMode"
                },
                "mountOptions": {
                    "$ref": "#/definitions/structs.CSIMountOptions"
                },
                "name": {
                    "type": "string"
                },
                "perAlloc": {
                    "type": "boolean"
                },
                "readOnly": {
                    "type": "boolean"
                },
                "source": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            }
        },
        "structs.WaitConfig": {
            "type": "object",
            "properties": {
                "max": {
                    "$ref": "#/definitions/time.Duration"
                },
                "min": {
                    "$ref": "#/definitions/time.Duration"
                }
            }
        },
        "structs.WorkloadIdentity": {
            "type": "object",
            "properties": {
                "audience": {
                    "description": "Audience is the valid recipients for this identity (the \"aud\" JWT claim)\nand defaults to the identity's name.",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "changeMode": {
                    "description": "ChangeMode is used to configure the task's behavior when the identity\ntoken changes.",
                    "type": "string"
                },
                "changeSignal": {
                    "description": "ChangeSignal is the signal sent to the task when a new token is\nretrieved. This is only valid when using the signal change mode.",
                    "type": "string"
                },
                "env": {
                    "description": "Env injects the Workload Identity into the Task's environment if\nset.",
                    "type": "boolean"
                },
                "file": {
                    "description": "File writes the Workload Identity into the Task's secrets directory\nif set.",
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "serviceName": {
                    "description": "ServiceName is used to bind the identity to a correct Consul service.",
                    "type": "string"
                },
                "ttl": {
                    "description": "TTL is used to determine the expiration of the credentials created for\nthis identity (eg the JWT \"exp\" claim).",
                    "allOf": [
                        {
                            "$ref": "#/definitions/time.Duration"
                        }
                    ]
                }
            }
        },
        "time.Duration": {
            "type": "integer",
            "enum": [
                -9223372036854775808,
                9223372036854775807,
                1,
                1000,
                1000000,
                1000000000,
                60000000000,
                3600000000000
            ],
            "x-enum-varnames": [
                "minDuration",
                "maxDuration",
                "Nanosecond",
                "Microsecond",
                "Millisecond",
                "Second",
                "Minute",
                "Hour"
            ]
        }
    },
    "securityDefinitions": {
        "BasicAuth": {
            "type": "basic"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "prospector.ie",
	BasePath:         "/api",
	Schemes:          []string{"https"},
	Title:            "Prospector API",
	Description:      "API backend for Prospector",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}
